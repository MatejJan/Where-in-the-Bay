// Generated by CoffeeScript 1.10.0
(function() {
  window.Terrain = (function() {
    function Terrain(size1, onMeshCreated) {
      var crustMaterial, material, terrainMaterial, texture;
      this.size = size1;
      terrainMaterial = new THREE.MeshLambertMaterial({
        color: 0x909090,
        map: new THREE.TextureLoader().load("terrain.png")
      });
      crustMaterial = new THREE.MeshLambertMaterial({
        color: 0x909090,
        map: new THREE.TextureLoader().load("crust.png")
      });
      material = new THREE.MultiMaterial();
      material.materials = [terrainMaterial, crustMaterial];
      this.height = this.size * 0.03;
      this.depth = this.size * 0.1;
      this.resolution = 800;
      texture = new THREE.TextureLoader().load("heightmap.png", (function(_this) {
        return function() {
          var bl, br, canvas, edgeIndicesOffset, geometry, height, heightFunction, i, image, imageData, j, k, l, m, n, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, size, tl, tr, uvs, x, y;
          image = texture.image;
          size = image.width;
          canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          canvas.getContext('2d').drawImage(image, 0, 0, size, size);
          imageData = canvas.getContext('2d').getImageData(0, 0, size, size).data;
          geometry = new THREE.Geometry();
          heightFunction = function(x, y) {
            var height, heightIndex, heightX, heightY;
            heightX = Math.floor(x * size / _this.resolution);
            heightY = Math.floor(y * size / _this.resolution);
            heightIndex = heightY * size + heightX;
            height = imageData[heightIndex * 4] - 12;
            if (height < 0) {
              height = -1;
            }
            return height;
          };
          _this.heightAt = function(x, y) {
            return heightFunction(x * _this.resolution, y * _this.resolution);
          };
          console.log("Creating vertices.");
          for (x = k = 0, ref = _this.resolution; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {
            for (y = l = 0, ref1 = _this.resolution; 0 <= ref1 ? l < ref1 : l > ref1; y = 0 <= ref1 ? ++l : --l) {
              height = heightFunction(x, y);
              geometry.vertices.push(new THREE.Vector3(x / (_this.resolution - 1) * _this.size, height / 255 * _this.height, y / (_this.resolution - 1) * _this.size));
            }
          }
          edgeIndicesOffset = geometry.vertices.length;
          for (i = m = 0, ref2 = _this.resolution; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
            for (j = n = 0; n <= 3; j = ++n) {
              x = i;
              y = i;
              switch (j) {
                case 0:
                  y = 0;
                  break;
                case 1:
                  y = _this.resolution - 1;
                  break;
                case 2:
                  x = 0;
                  break;
                case 3:
                  x = _this.resolution - 1;
              }
              height = heightFunction(x, y);
              geometry.vertices.push(new THREE.Vector3(x / (_this.resolution - 1) * _this.size, height / 255 * _this.height, y / (_this.resolution - 1) * _this.size));
              geometry.vertices.push(new THREE.Vector3(x / (_this.resolution - 1) * _this.size, -_this.depth, y / (_this.resolution - 1) * _this.size));
            }
          }
          console.log("Creating faces.");
          for (x = o = 0, ref3 = _this.resolution - 1; 0 <= ref3 ? o < ref3 : o > ref3; x = 0 <= ref3 ? ++o : --o) {
            for (y = p = 0, ref4 = _this.resolution - 1; 0 <= ref4 ? p < ref4 : p > ref4; y = 0 <= ref4 ? ++p : --p) {
              tl = y * _this.resolution + x;
              tr = tl + 1;
              bl = (y + 1) * _this.resolution + x;
              br = bl + 1;
              geometry.faces.push(new THREE.Face3(tl, br, bl));
              geometry.faces.push(new THREE.Face3(tl, tr, br));
              uvs = {
                tl: new THREE.Vector2(y / (_this.resolution - 1), 1 - (x / (_this.resolution - 1))),
                tr: new THREE.Vector2(y / (_this.resolution - 1), 1 - ((x + 1) / (_this.resolution - 1))),
                bl: new THREE.Vector2((y + 1) / (_this.resolution - 1), 1 - (x / (_this.resolution - 1))),
                br: new THREE.Vector2((y + 1) / (_this.resolution - 1), 1 - ((x + 1) / (_this.resolution - 1)))
              };
              geometry.faceVertexUvs[0].push([uvs.tl, uvs.br, uvs.bl]);
              geometry.faceVertexUvs[0].push([uvs.tl, uvs.tr, uvs.br]);
            }
          }
          for (i = q = 0, ref5 = _this.resolution - 1; 0 <= ref5 ? q < ref5 : q > ref5; i = 0 <= ref5 ? ++q : --q) {
            for (j = r = 0; r <= 3; j = ++r) {
              tl = edgeIndicesOffset + i * 8 + j * 2;
              bl = tl + 1;
              tr = tl + 8;
              br = tr + 1;
              uvs = {
                tl: new THREE.Vector2(i / (_this.resolution - 1), 1),
                tr: new THREE.Vector2((i + 1) / (_this.resolution - 1), 1),
                bl: new THREE.Vector2(i / (_this.resolution - 1), 0),
                br: new THREE.Vector2((i + 1) / (_this.resolution - 1), 0)
              };
              if (j === 0 || j === 3) {
                geometry.faces.push(new THREE.Face3(tl, tr, bl, null, null, 1));
                geometry.faces.push(new THREE.Face3(bl, tr, br, null, null, 1));
                geometry.faceVertexUvs[0].push([uvs.tl, uvs.tr, uvs.bl]);
                geometry.faceVertexUvs[0].push([uvs.bl, uvs.tr, uvs.br]);
              } else {
                geometry.faces.push(new THREE.Face3(tl, bl, tr, null, null, 1));
                geometry.faces.push(new THREE.Face3(bl, br, tr, null, null, 1));
                geometry.faceVertexUvs[0].push([uvs.tl, uvs.bl, uvs.tr]);
                geometry.faceVertexUvs[0].push([uvs.bl, uvs.br, uvs.tr]);
              }
            }
          }
          console.log("Computing attributes.");
          geometry.computeFaceNormals();
          geometry.computeVertexNormals();
          geometry.computeBoundingBox();
          geometry.computeBoundingSphere();
          console.log("Terrain created.");
          _this.mesh = new THREE.Mesh(geometry, material);
          return onMeshCreated(_this.mesh);
        };
      })(this));
    }

    return Terrain;

  })();

}).call(this);

//# sourceMappingURL=terrain.js.map
